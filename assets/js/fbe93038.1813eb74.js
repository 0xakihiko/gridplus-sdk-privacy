"use strict";(self.webpackChunkgridplus_sdk=self.webpackChunkgridplus_sdk||[]).push([[432],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),m=i,h=c["".concat(o,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4534:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return o},metadata:function(){return u},toc:function(){return p},default:function(){return c}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],s={},o="Testing",u={unversionedId:"testing",id:"testing",title:"Testing",description:"If you have a Lattice1 device that is connected to the internet, you can run the full test suite with:",source:"@site/docs/testing.md",sourceDirName:".",slug:"/testing",permalink:"/gridplus-sdk/docs/testing",editUrl:"https://github.com/gridplus/gridplus-sdk/docs/testing.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Introduction",permalink:"/gridplus-sdk/docs/intro"},next:{title:"Client",permalink:"/gridplus-sdk/docs/api/classes/Client"}},p=[{value:"Signing",id:"signing",children:[],level:2},{value:"Test Suites",id:"test-suites",children:[{value:"Test Suite Options",id:"test-suite-options",children:[],level:3},{value:"Ethereum",id:"ethereum",children:[{value:"Options",id:"options",children:[],level:4}],level:3},{value:"Ethereum Messages",id:"ethereum-messages",children:[{value:"Options",id:"options-1",children:[],level:4}],level:3},{value:"Ethereum ABI",id:"ethereum-abi",children:[{value:"Options",id:"options-2",children:[],level:4}],level:3}],level:2},{value:"Dev Lattice Tests",id:"dev-lattice-tests",children:[{value:"Bitcoin",id:"bitcoin",children:[{value:"Options",id:"options-3",children:[],level:4}],level:3},{value:"Wallet Jobs",id:"wallet-jobs",children:[],level:3},{value:"Signatures",id:"signatures",children:[{value:"Options",id:"options-4",children:[],level:4}],level:3}],level:2},{value:"Test Harness",id:"test-harness",children:[],level:2}],d={toc:p};function c(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"testing"},"Testing"),(0,r.kt)("p",null,"If you have a Lattice1 device that is connected to the internet, you can run the full test suite with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm test\n")),(0,r.kt)("p",null,"By default, running tests this way will pair with your Lattice device each time you run the tests. "),(0,r.kt)("p",null,"If you aren't testing the pairing process, you can reuse the pairing key for each test by passing an\nenvironment variable, ",(0,r.kt)("inlineCode",{parentName:"p"},"REUSE_KEY"),", when pairing like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env REUSE_KEY=1 npm test\n")),(0,r.kt)("p",null,"All subsequent tests will re-use the key if you specify your device ID as an environment variable like this: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm test\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note"),": By default, your Lattice will utilize its on-board wallet. If you wish to test against a SafeCard, you will need to insert it and PIN it (i.e. the card needs to be set up). If you reboot your unit, you will need to remove the card and re-insert (and re-authenticate) before testing against it.")),(0,r.kt)("h2",{id:"signing"},"Signing"),(0,r.kt)("p",null,"Once you have paired with a device in a re-usable way (i.e. setting ",(0,r.kt)("inlineCode",{parentName:"p"},"REUSE_KEY=1")," as above), you can run more robust tests around signing. "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note"),": If you are testing with a dev Lattice, it is highly recommended that you compile the\nautosign flag into your firmware (or else you will need to press accept ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," times).")),(0,r.kt)("h2",{id:"test-suites"},"Test Suites"),(0,r.kt)("p",null,"There are a series of test suites that can be used to validate the SDK's behavior. Each can be run independently using the commands as described below. "),(0,r.kt)("h3",{id:"test-suite-options"},"Test Suite Options"),(0,r.kt)("p",null,"Some test suites allow for additional options that allow for more versatile testing configurations. These options are passed in as environment variables like this: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' N=25 npm test\n")),(0,r.kt)("p",null,"See the options area for each test suite for which options are usable with that suite."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h4",{parentName:"li",id:"n"},(0,r.kt)("inlineCode",{parentName:"h4"},"N")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default=3")),(0,r.kt)("li",{parentName:"ul"},"number of inputs per test. Note that if you choose e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"N=2")," each test will first test one input, then will test two. Must be >0 and <11."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h4",{parentName:"li",id:"seed"},(0,r.kt)("inlineCode",{parentName:"h4"},"SEED")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'default="myrandomseed"')," "),(0,r.kt)("li",{parentName:"ul"},"randomness for the pseudorandom number generator that builds deterministic test vectors"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("h4",{parentName:"li",id:"testnet"},(0,r.kt)("inlineCode",{parentName:"h4"},"TESTNET")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default=false")," "),(0,r.kt)("li",{parentName:"ul"},"if set to any value you will test all combinations for both mainnet and testnet transactions (doubles number of tests run)")))),(0,r.kt)("h3",{id:"ethereum"},"Ethereum"),(0,r.kt)("p",null,"Ethereum tests include both boundary checks on transaction params and randomized test vectors (20 by\ndefault). "),(0,r.kt)("p",null,"Run the suite with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm run test-eth\n")),(0,r.kt)("h4",{id:"options"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#n"},(0,r.kt)("inlineCode",{parentName:"a"},"N"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#seed"},(0,r.kt)("inlineCode",{parentName:"a"},"SEED")))),(0,r.kt)("h3",{id:"ethereum-messages"},"Ethereum Messages"),(0,r.kt)("p",null,"You may test Ethereum messages sent to the Lattice with the following script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm run test-eth-msg\n")),(0,r.kt)("h4",{id:"options-1"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#n"},(0,r.kt)("inlineCode",{parentName:"a"},"N"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#seed"},(0,r.kt)("inlineCode",{parentName:"a"},"SEED")))),(0,r.kt)("h3",{id:"ethereum-abi"},"Ethereum ABI"),(0,r.kt)("p",null,"You may test functionality around loading Ethereum ABI definitions and displaying calldata in a markdown screen with the following script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm run test-eth-abi\n")),(0,r.kt)("h4",{id:"options-2"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#seed"},(0,r.kt)("inlineCode",{parentName:"a"},"SEED")))),(0,r.kt)("h2",{id:"dev-lattice-tests"},"Dev Lattice Tests"),(0,r.kt)("p",null,"The following tests ",(0,r.kt)("em",{parentName:"p"},"require")," a development Lattice to complete successfully."),(0,r.kt)("h3",{id:"bitcoin"},"Bitcoin"),(0,r.kt)("p",null,"Bitcoin tests cover legacy, wrapped segwit, and segwit spending to all address types. Vectors are built deterministically using the seed and all permutations are tested."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm run test-btc\n")),(0,r.kt)("h4",{id:"options-3"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#n"},(0,r.kt)("inlineCode",{parentName:"a"},"N"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#seed"},(0,r.kt)("inlineCode",{parentName:"a"},"SEED"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#testnet"},(0,r.kt)("inlineCode",{parentName:"a"},"TESTNET")))),(0,r.kt)("h3",{id:"wallet-jobs"},"Wallet Jobs"),(0,r.kt)("p",null,'Lattice firmware uses "wallet jobs" to interact with the SafeCard/Lattice wallet directly. The SDK does not have access to these methods in production builds, but for debug builds the test harness can be used to interact with them.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm run test-wallet-jobs\n")),(0,r.kt)("h3",{id:"signatures"},"Signatures"),(0,r.kt)("p",null,"Tests signing with and without SafeCards."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"env DEVICE_ID='my_device_id' npm run test-sigs\n")),(0,r.kt)("h4",{id:"options-4"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#n"},(0,r.kt)("inlineCode",{parentName:"a"},"N"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#seed"},(0,r.kt)("inlineCode",{parentName:"a"},"SEED")))),(0,r.kt)("h2",{id:"test-harness"},"Test Harness"),(0,r.kt)("p",null,"We can test debug firmware builds using the ",(0,r.kt)("inlineCode",{parentName:"p"},"client.test")," function in the SDK. This utilizes the firmware's test harness with an encrypted route. You can run these tests with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"env DEVICE_ID='my_device_id")," flag as some of the other tests."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: Since these are encrypted routes, you need to be paired with your Lattice before you can run them (using ",(0,r.kt)("inlineCode",{parentName:"p"},"env REUSE_KEY=1 npm test")," as before -- you still only need to do this once).")))}c.isMDXComponent=!0}}]);